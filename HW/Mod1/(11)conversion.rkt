(define (certain->decimal s b) 
  (let ((lst (string->list s))) 
    (define (helper lst b) 
      (if (null? lst) 
          0 
          (let ((x (char->integer (car lst)))) 
            (if (correct-number? s b) 
                (cond 
                  ((and (>= x 48) (<= x 57) 
                        (+ (* (- x 48) (expt b (- (length lst) 1))) (helper (cdr lst) b)))) 
                  ((and (>= x 65) (<= x 90) 
                        (+ (* (- x 55) (expt b (- (length lst) 1))) (helper (cdr lst) b)))) 
                  ((and (>= x 97) (<= x 122) 
                        (+ (* (- x 87) (expt b (- (length lst) 1))) (helper (cdr lst) b))))) 
                'number-conversion-error)))) 
    (helper lst b))) 

(define (correct-number? s b) 
  (let ((lst (string->list s))) 
    (define (helper lst b) 
      (if (null? lst) #t 
          (let ((x (char->integer (car lst)))) 
            (and (or (and (>= x 48) (<= x 57) (< (- x 48) b)) 
                     (and (>= x 65) (<= x 90) (< (- x 55) b)) 
                     (and (>= x 97) (<= x 122) (< (- x 87) b))) 
                 (helper (cdr lst) b))))) 
    (helper lst b))) 

(define (decimal->certain d b) 
  (define (helper a b) 
    (let ((c (quotient a b)) 
          (d (remainder a b))) 
      (if (> c 0) 
          (and (or (and (>= d 0) (<= d 9) (set! d (+ d 48))) 
                   (and (>= d 10) (<= d 61) (set! d (+ d 87)))) 
               (string-append (string (integer->char d)) (helper c b))) 
          (or (and (>= a 0) (<= a 9) (string (integer->char (+ a 48)))) 
              (and (>= a 10) (<= a 61) (string (integer->char (+ a 87)))))))) 
  (let ((c (helper d b))) 
    (list->string (reverse (string->list c)))))